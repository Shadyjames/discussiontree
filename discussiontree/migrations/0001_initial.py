# -*- coding: utf-8 -*-
# Generated by Django 1.11.5 on 2017-09-23 10:01
from __future__ import unicode_literals

import django.contrib.postgres.fields.jsonb
from django.db import migrations, models
import django.db.models.deletion

def populate_initial(apps, schema_editor):
    # Create the base node types
    NodeType = apps.get_model('discussiontree.NodeType')
    NodeSubType = apps.get_model('discussiontree.NodeSubType')
    NodeTypeConnectivity = apps.get_model('discussiontree.NodeTypeConnectivity')

    # Create the core node types
    question_type = NodeType.objects.create(name="Question", credibility_factor=0)
    proposition_type = NodeType.objects.create(name="Proposition", credibility_factor=0)
    evidence_type = NodeType.objects.create(name="Evidence", credibility_factor=1)
    refutation_type = NodeType.objects.create(name="Refutation", credibility_factor=-1)
    condition_type = NodeType.objects.create(name="Condition", credibility_factor=0)
    citation_type = NodeType.objects.create(name="Citation", credibility_factor=0)
    citation_needed_type = NodeType.objects.create(name="Citation needed", credibility_factor=-1)
    citation_filled_type = NodeType.objects.create(name="Citation filled", credibility_factor=-1, affects_parent_owner_cred=False)
    misuse_type = NodeType.objects.create(name="Misuse declaration", credibility_factor=-1)
    link_type = NodeType.objects.create(name="Link to other tree", credibility_factor=0)
    # TODO connectivity for condition, question, misuse, citation, links

    # Questions can only be answered by propositions, or marked as misuse, or linked to existing propositions
    NodeTypeConnectivity.objects.create(parent=question_type, child=proposition_type)
    NodeTypeConnectivity.objects.create(parent=question_type, child=misuse_type)
    NodeTypeConnectivity.objects.create(parent=question_type, child=link_type)

    # Propositions can only be supported by evidence, or marked as misuse, or have condition subtrees
    NodeTypeConnectivity.objects.create(parent=proposition_type, child=evidence_type)
    NodeTypeConnectivity.objects.create(parent=proposition_type, child=misuse_type)
    NodeTypeConnectivity.objects.create(parent=proposition_type, child=condition_type)

    # Evidence can only be refuted, or have citation-related nodes
    NodeTypeConnectivity.objects.create(parent=evidence_type, child=refutation_type)
    NodeTypeConnectivity.objects.create(parent=evidence_type, child=citation_type)
    NodeTypeConnectivity.objects.create(parent=evidence_type, child=citation_needed_type)

    # Refutations can be refuted, and also take direct citations
    NodeTypeConnectivity.objects.create(parent=refutation_type, child=refutation_type)
    NodeTypeConnectivity.objects.create(parent=refutation_type, child=citation_type)
    NodeTypeConnectivity.objects.create(parent=refutation_type, child=citation_needed_type)

    # Conditions can have the same children as propositions since they're
    # essentially just a subtree node for propositions. But they can also link to
    # other propositions which examine the validity of the condition
    NodeTypeConnectivity.objects.create(parent=condition_type, child=evidence_type)
    NodeTypeConnectivity.objects.create(parent=condition_type, child=misuse_type)
    NodeTypeConnectivity.objects.create(parent=condition_type, child=link_type)

    # Citations can only have misuse declarations
    NodeTypeConnectivity.objects.create(parent=citation_type, child=misuse_type)

    # Citation needed can have citation filled or misuse declarations as children
    NodeTypeConnectivity.objects.create(parent=citation_needed_type, child=citation_filled_type)
    NodeTypeConnectivity.objects.create(parent=citation_needed_type, child=misuse_type)

    # Citation filled cannot have any children.

    # Misuse declaration cannot have any children.

    # Link type cannot have any children. (link is not a parent/child connection, just a url)

    # Create the subtypes

    # Claims don't have subtypes that i'm aware of so every proposition is an "other proposition".
    # The frontend will hide the subtype abstraction for all types with only 1 subtype.
    NodeSubType.objects.create(
        super_type=proposition_type,
        name="Proposition",
        explanation="A proposition is a statement of a contentious point, phrased as a fact, to create a place for discussion about the points merits. For example: \"We live in a simulated reality\" would be a valid proposition. Do not include qualifiers or assumptions in your proposal. The words \"if\", \"assuming\", nor any similar substitutes should ever be included in a proposition",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=citation_type,
        name="Citation",
        explanation="Supporting documentation for a piece of evidence or a refutation thereof. Include relevant quotes from the source, as well as bibliographic/authorship details where possible, in case the URL goes down in future.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=citation_needed_type,
        name="Citation needed",
        explanation="If somebody has made a statement which you suspect may not be based in fact, request a citation. Keep in mind that its not constructive to demand citations for facts which are self evident, trivially falsifiable, or universally accepted. If you demand a citation for the sky being blue, you will be hit with a misuse declaration and your credibility will suffer.",
        template=["The following statement requires a citation: ", None]
    )
    NodeSubType.objects.create(
        super_type=citation_filled_type,
        name="Citation filled",
        explanation="If a \"citation needed\" node is obsolete because citations have been added to its parent node since then, use this node to nullify the effects of the \"citation needed\" node",
        template=["Since the creation of this citation needed node, citations have been added, so there is no or limited need for further citations", None]
    )
    NodeSubType.objects.create(
        super_type=misuse_type,
        name="Misuse declaration",
        explanation="If a node has been created which does not meet the guidelines for its node type, use this node to mark it as unconstructive, unnecessary or malicious",
        template=["This node does not meet the guidelines for its node type. Whether it is asking a loaded question, is inflammatory, unconstructive, word salad, or something else entirely, it does not foster constructive discussion. If you agree that it does not foster constructive discussion, you are encouraged to mark this misuse declaration as constructive, to reduce the credibility of the target node. If you disagree, and think the target node is constructive and this declaration is uncalled for, you are encouraged to mark the target node as constructive instead to protect its credibility.", None]
    )
    NodeSubType.objects.create(
        super_type=link_type,
        name="Link to other tree",
        explanation="If there already exists a proposal which answers a question, or examines the validity of the assumption(s) put forth by a condition node, you are encouraged to use a link node to connect that proposal to the relevant question/condition. This helps people find the discussions that they wish to participate in, reduces duplication, and makes both trees more useful! Please include the ID of the node you wish to link, in the node body. DiscussionTree will do the rest using magic.",
        template=["The following proposition is relevant to this discussion: ", None]
    )

    # Evidence comes in two types.
    NodeSubType.objects.create(
        super_type=evidence_type,
        name="Deductive (proof)",
        explanation="Deductive evidence is a logical proof that a set of axioms lead to a certain conclusion. The axioms do not need to be supported if they are self-evident, but contentious axioms must be supported",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=evidence_type,
        name="Observed (statistical)",
        explanation="Observed evidence is evidence provided by one or more observations (such as a study). Correlation does not imply causation, but a large body of correlational evidence which controls for confounding factors can be adequate to \"prove\" certain claims to within a trivial margin of error. Observed evidence is only as strong as its statistical significance.",
        template=[None]
    )

    # Refutations come in many types
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Appeal to ignorance",
        explanation="The appeal to ignorance (argumentum ad ignorantiam) is a fallacy that asserts that an argument is true because it has not been proven false (or vice versa)",
        template=["The assertion that ", None, "simply on the grounds that it has not been proven incorrect is an attempt to shift the burden of proof, and does not constitute evidence", None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Argument from incredulity (appeal to common sense)",
        explanation="The argument from incredulity is a fallacy that asserts an argument is true because true because the alternative seems superficially ridiculous (or vice versa), but does not actually refute the argument",
        template=["Asserting something must be true because the alternative seems superficially ridiculous does not constitute evidence. A superficial or \"common sense\" analysis has no explanatory power and is no substitute for scientific rigor.", None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Begging the question",
        explanation="Begging the question is to put forward an argument whose validity requires that its own conclusion is true.",
        template=["This argument requires that its conclusion must be true for the argument to be valid. This is a form of circular reasoning", None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Fallacy of composition",
        explanation="The fallacy of composition is when the assumption is made that something that is true of a part must also be true of the whole. eg. Tyres are made of rubber, and tyres are part of a car, therefore cars must be made of rubber.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Suppressed correlative",
        explanation="The fallacy of suppressed correlative is a type of argument that tries to redefine a correlative (one of two mutually exclusive options) so that one alternative encompasses the other, i.e. making one alternative impossible.",
        template=["This argument attempts to redefine the category \"", None, "\" so that it is egregiously inclusive", None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Ecological fallacy",
        explanation="The ecological fallacy is a logical fallacy in the interpretation of statistical data where inferences about the nature of individuals are deduced from inference for the group to which those individuals belong.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Inspecific claim (Incomplete comparison)",
        explanation="Inspecific claims often use un-quantifiable metrics like \"better\" to prevent any rational assessment of the statements truthfulness",
        template=["The statement \"", None, "\" is not specific enough to be assessed or falsified", None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Circular reasoning",
        explanation="Circular reasoning is a large category of fallacies where where an argument relies (directly or indirectly) on one of its own outcomes in order to be sound",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Naturalistic/Moralistic fallacies",
        explanation="The Naturalistic and Moralistic fallacies are a pair of fallacies which involve violation of the fact-value distinction. Simply, confusing what must be with what should be. The naturalistic fallacy is inferring \"is\" from \"ought\", and the moralistic fallacy is the inverse. \"Nature isn't supposed to be fair or just, you've got that confused with society\"",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Proof by assertion",
        explanation="Re-asserting a point does not increase its validity; only evidence does",
        template=["No point should ever be re-asserted in its own subtree - If it is valid, simply show that all refutations of the original node for that point are NOT valid, by creating counter-refutations. Re-assertion is grounds for node deletion"]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Special pleading (moving the goalposts)",
        explanation="Claiming that a counterpoint simply constitutes a special exemption from the rule, not contrary evidence.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Incorrect/unsupported axiom(s)",
        explanation="All proofs rely on a set of initial assumptions (known as axioms) in order to deduce further truths. Even if the proof itself is flawless, it proves nothing unless its initial assumptions are irrefutible.",
        template=["Regardless of the validity of your proof, it relies on the assumption that ", None, ". In lieu of the fact that is either not the case, or still under contention, your proof cannot stand"]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Word salad",
        explanation="A word salad is a set of words that make sense individually but do not have any coherent meaning in the order they have been assembled. Word salad is a serious offense and represents a total lack of either comprehension or respect for rational discourse.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Correlation does not imply causation",
        explanation="Even when there is a large number of observations, correlative evidence must control for confounding variables in order to be valid.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Not statistically significant",
        explanation="Correlational evidence is only valid if there is a great enough number of observations to be statistically significant. Evidence using small sample sizes - or worse a sample size of 1, known as anecdotal evidence - can easily be produced to support every falsifiable conclusion, if enough trials are run and cherrypicked. This does not mean the conclusion is true",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Misuse/misunderstanding of probability",
        explanation="Wastebasket refutation for any fallacy involving misuse or misunderstanding of probability. eg. if the false positive rate for a breast cancer test is 1 in 100, and the rate of breast cancer in the population is 1 in 1000, a positive test still means you're very unlikely to have breast cancer (10% probability).",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Other non-sequitur",
        explanation="Wastebasket refutation for any fallacy where the conclusion is not actually implied by the argument.",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Incorrect deduction",
        explanation="Wastebasket refutation for any fallacy involving incorrect deductive reasoning",
        template=[None]
    )
    NodeSubType.objects.create(
        super_type=refutation_type,
        name="Freeform refutation",
        explanation="This refutation does not fall into any other category. If you think it belongs in a new category that's missing, consider contacting the developer or webmaster to add it to the database of refutation types.",
        template=[None]
    )


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='DiscussionNode',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.TextField()),
                ('body', models.TextField()),
            ],
        ),
        migrations.CreateModel(
            name='NodeSubType',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField()),
                ('explanation', models.TextField()),
                ('template', django.contrib.postgres.fields.jsonb.JSONField()),
            ],
        ),
        migrations.CreateModel(
            name='NodeType',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.TextField()),
                ('credibility_factor', models.IntegerField()),
                ('affects_parent_owner_cred', models.BooleanField(default=True)),
            ],
        ),
        migrations.CreateModel(
            name='NodeTypeConnectivity',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('child', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='+', to='discussiontree.NodeType')),
                ('parent', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='+', to='discussiontree.NodeType')),
            ],
        ),
        migrations.AddField(
            model_name='nodesubtype',
            name='super_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='discussiontree.NodeType'),
        ),
        migrations.AddField(
            model_name='discussionnode',
            name='node_subtype',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='discussiontree.NodeSubType'),
        ),
        migrations.AddField(
            model_name='discussionnode',
            name='parent',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='discussiontree.DiscussionNode'),
        ),
        migrations.RunPython(populate_initial),
    ]
